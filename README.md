# Buffer-Overflow-Exploitation
Buffer Overflow Exploitation
In a simple program where the user is required to input their email address, we allocate a fixed amount of memory, let's say 100 bytes. However, we don't include any conditions to check if the user exceeds this size limit when entering their email address. The consequence of this oversight is that if the user enters an email address that's, let's say, 150 bytes long, the extra 50 bytes will overflow into memory allocated for other variables. This will disrupt the program's behavior, potentially causing unintended results. Essentially, this situation leads to a buffer overflow, which is a common security vulnerability and could be exploited by individuals with malicious intent.

![image](https://github.com/Sumanthsec/Buffer-Overflow-Exploitation/assets/123907433/ef667e9c-d194-4fbb-9eb8-7c338ffdb777)

Functions like printf and sprintf can be vulnerable if they are printing user input that isn't properly validated. This can allow attackers to read or write data from the stack, essentially leading to a stack overflow attack.
Insecure library functions like gets and strcpy do not typically check the size of the buffer and are known to cause buffer overflow attacks.

An attacker could potentially manipulate the program by overwriting the return pointer to redirect it to a specific address of their choosing. This action is done to achieve their own objectives or gain an advantage.

![image](https://github.com/Sumanthsec/Buffer-Overflow-Exploitation/assets/123907433/a7dbcad7-4f2e-4a18-b21d-79bed81fd965)

In the traditional x86 architecture, the stack top is located at the highest memory address.

Stack based overflow vs heap-based overflow.
When it comes to a stack-based overflow, the attacker targets the vulnerabilities in the stack memory, which stores functions and local variables. On the other hand, in a heap-based overflow, they target the heap memory, which is used for dynamic memory allocation through functions like malloc.
It is usually harder for attackers to perform heap overflow attacks since the memory layout in the heap is very complex compared to that of the stack. As it contains objects that are dynamically allocated, it makes it hard for the attacker to follow and predict the addresses.
In stack overflow attacks, the return address is typically overwritten to redirect program execution, whereas in heap overflow attacks, data structures and function pointers must be manipulated to control the program's behavior.

Per-system call stack randomization.
As we know, Address Space Layout Randomization (ASLR) randomizes sections of the program's memory each time the program is executed, leading to changing addresses of functions, variables, and buffers with every run.
Similarly, the per-system call stack randomization is built on a similar concept, where the randomization occurs each time a system call is made, rather than randomizing at the program startup like ASLR.
So, every time a system call is made, the kernel's stack is randomized, leading to changing addresses of functions, variables, and buffers with every system call.

Whenever a system call is made, a transition is made from the user mode to the kernel mode in order to call the glibc library. So, in this process of mode switching, the user's context is saved before switching to the kernel. This is done so that after the system call, the saved registers can be stored to restore program execution smoothly. If the registers aren't saved before switching the mode from user to kernel, randomization of the stack might have an unstable impact on the program's execution, leading to a program crash.
